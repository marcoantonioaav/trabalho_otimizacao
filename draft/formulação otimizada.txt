function solve(instance_name, n, k, cI, cP, p, P)
    m = Model();
    set_optimizer(m, GLPK.Optimizer);

    @variable(m, estaNoAviao[1:n, 1:k] >= 0, Bin);  #estaNoAviao[i, j] = a pessoa i está no avião j? 
    M = n+k+1 #big M

    #saida
    @variable(m, A[1:n] >= 1, Int);  #aloca as pessoas nos avioes (qual aviao A[i] esta a pessoa i)
    @variable(m, S[1:n] >= 0, Bin);  #seleção de pessoas (a pessoa i esta em um aviao?)

    @objective(m, Max, sum(cI[pessoa]*S[pessoa] for pessoa=1:n) + sum(cP[p1][p2]*sum(estaNoAviao[p1, aviao]*estaNoAviao[p2, aviao] for aviao=1:k) for p1=1:n for p2=1:n)/2);

    for pessoa=1:n
        @constraint(m, A[pessoa] <= k); #Limita valores de aviões
        @constraint(m, sum(estaNoAviao[pessoa, aviao] for aviao=1:k) == S[pessoa]); #Se uma pessoa está em qualquer avião, esta pessoa foi selecionada
    end
    for aviao=1:k
        for pessoa=1:n
            @constraint(m, A[pessoa] <= aviao + M*(1-estaNoAviao[pessoa, aviao])); #mapeia A[pessoa] em aviões
            @constraint(m, M*(1-estaNoAviao[pessoa, aviao]) + A[pessoa] >= aviao); #mapeia A[pessoa] em aviões
        end
        @constraint(m, sum(p[pessoa]*estaNoAviao[pessoa, aviao] for pessoa=1:n) <= P[aviao]); #limita a ocupação dos aviões pelo seu peso maximo
        
    end

    println("Solving instance "*instance_name)
    optimize!(m);
    log_result(instance_name, A, S, objective_value(m));
end
